#!/usr/bin/env perl
#

$unused_header = q`

                       p10-unwrap.pl

This pass takes output from the plugin and un-wraps lines so that each
node is entirely on a single line. It also removes 'chain:' attributes
and extra whitespace.

Sample input (as generated by the plugin) :

  @14     expr_stmt        type: @4       line: 7        expr: @22     
  @15     integer_type     name: @23      size: @24      algn: 32      
                           prec: 32       sign: signed   min : @25     
                           chain: @37     max : @26     
  @16     result_decl      type: @15      srcp: test1.cc:1      
                           note: artificial              size: @24     
                           algn: 32      

Output of this pass:

  @14 expr_stmt type: @4 line: 7 expr: @22
  @15 integer_type name: @23 size: @24 algn: 32 prec: 32 sign: signed min : @25 max : @26
  @16 result_decl type: @15 srcp: test1.cc:1 note: artificial size: @24 algn: 32

`;

sub flsh
{
  print $cmts; # Already includes its newline(s)
  if ($node ne '') {
    $node =~ s/ integer_cst / int_const /;
    $node =~ s/ real_cst / real_const /;
    $node =~ s/ string_cst / str_const /;

    #$node =~ s/ max :/ max_:/g;
    #$node =~ s/ min :/ min_:/g;
    #$node =~ s/ ptd :/ ptd_:/g;
    #$node =~ s/ tag :/ tag_:/g;
    #$node =~ s/ op ([0-9])/ op_\1/g;

    $node =~ s/ +/ /g;
    print "$node\n";
  }
  print $spcl;
  $node = $cmts = $spcl = '';
}

$node = $cmts = $spcl = '';
while($l = <>) {
  chomp $l;
  $l =~ s/[ \t]+/ /g;
  if ($l =~ m/^\@[0-9]/) {
    # Beginning of a node. Flush previous accumulated text.
    &flsh();
    $node = $l;
  } elsif ($l =~ m/^ /) {
    # Continuation
    $node .= $l;
  } elsif ($l =~ m/^#/) {
    # Comments - leave as-is. These can be in the middle of a node, but
    # we defer nodes until they are complete. That means we must save comments too.
    $cmts .= "$l\n";
  } else {
    # Special lines - handled similarly to comments.
    $spcl .= "$l\n";
  }
}
&flsh();
